<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ğŸš§ async et await - La programmation asynchrone avec Rust</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01_getting_started/01_chapter.html"><strong aria-hidden="true">1.</strong> ğŸš§ Pour dÃ©marrer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01_getting_started/02_why_async.html"><strong aria-hidden="true">1.1.</strong> ğŸš§ Pourquoi l'asynchrone ?</a></li><li class="chapter-item expanded "><a href="../01_getting_started/03_state_of_async_rust.html"><strong aria-hidden="true">1.2.</strong> ğŸš§ L'Ã©tat de l'art de l'asynchrone en Rust</a></li><li class="chapter-item expanded "><a href="../01_getting_started/04_async_await_primer.html"><strong aria-hidden="true">1.3.</strong> ğŸš§ Introduction Ã  async et await</a></li></ol></li><li class="chapter-item expanded "><a href="../02_execution/01_chapter.html"><strong aria-hidden="true">2.</strong> ğŸš§ Sous le capotÂ : exÃ©cuter les Futures et les tÃ¢ches</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02_execution/02_future.html"><strong aria-hidden="true">2.1.</strong> ğŸ’¬ The Future Trait</a></li><li class="chapter-item expanded "><a href="../02_execution/03_wakeups.html"><strong aria-hidden="true">2.2.</strong> ğŸ’¬ Task Wakeups with Waker</a></li><li class="chapter-item expanded "><a href="../02_execution/04_executor.html"><strong aria-hidden="true">2.3.</strong> ğŸ’¬ Applied: Build an Executor</a></li><li class="chapter-item expanded "><a href="../02_execution/05_io.html"><strong aria-hidden="true">2.4.</strong> ğŸ’¬ Executors and System IO</a></li></ol></li><li class="chapter-item expanded "><a href="../03_async_await/01_chapter.html" class="active"><strong aria-hidden="true">3.</strong> ğŸš§ async et await</a></li><li class="chapter-item expanded "><a href="../04_pinning/01_chapter.html"><strong aria-hidden="true">4.</strong> ğŸš§ L'Ã©pinglage</a></li><li class="chapter-item expanded "><a href="../05_streams/01_chapter.html"><strong aria-hidden="true">5.</strong> ğŸš§ Le trait Stream</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05_streams/02_iteration_and_concurrency.html"><strong aria-hidden="true">5.1.</strong> ğŸš§ L'itÃ©ration et la concurrence</a></li></ol></li><li class="chapter-item expanded "><a href="../06_multiple_futures/01_chapter.html"><strong aria-hidden="true">6.</strong> ğŸš§ ExÃ©cuter plusieurs futures en mÃªme temps</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06_multiple_futures/02_join.html"><strong aria-hidden="true">6.1.</strong> ğŸš§ join!</a></li><li class="chapter-item expanded "><a href="../06_multiple_futures/03_select.html"><strong aria-hidden="true">6.2.</strong> ğŸš§ select!</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> ğŸ¥š TODO: Spawning</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> ğŸ¥š TODO: Cancellation and Timeouts</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> ğŸ¥š TODO: FuturesUnordered</div></li></ol></li><li class="chapter-item expanded "><a href="../07_workarounds/01_chapter.html"><strong aria-hidden="true">7.</strong> ğŸš§ Solutions de contournement Ã  connaÃ®tre et Ã  utiliser</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../07_workarounds/02_err_in_async_blocks.html"><strong aria-hidden="true">7.1.</strong> ğŸš§ ? dans les blocs async</a></li><li class="chapter-item expanded "><a href="../07_workarounds/03_send_approximation.html"><strong aria-hidden="true">7.2.</strong> ğŸš§ L'approximation de Send</a></li><li class="chapter-item expanded "><a href="../07_workarounds/04_recursion.html"><strong aria-hidden="true">7.3.</strong> ğŸš§ La rÃ©cursivitÃ©</a></li><li class="chapter-item expanded "><a href="../07_workarounds/05_async_in_traits.html"><strong aria-hidden="true">7.4.</strong> ğŸš§ async dans les traits</a></li></ol></li><li class="chapter-item expanded "><a href="../08_ecosystem/00_chapter.html"><strong aria-hidden="true">8.</strong> ğŸš§ L'Ã©cosystÃ¨me asynchrone</a></li><li class="chapter-item expanded "><a href="../09_example/00_intro.html"><strong aria-hidden="true">9.</strong> ğŸš§ Projet finalÂ : Serveur HTTP</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../09_example/01_running_async_code.html"><strong aria-hidden="true">9.1.</strong> ğŸš§ ExÃ©cuter du code asynchrone</a></li><li class="chapter-item expanded "><a href="../09_example/02_handling_connections_concurrently.html"><strong aria-hidden="true">9.2.</strong> ğŸš§ GÃ©rer les connexions en concurrence</a></li><li class="chapter-item expanded "><a href="../09_example/03_tests.html"><strong aria-hidden="true">9.3.</strong> ğŸš§ Test du serveur</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> TODO: I/O</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> TODO: AsyncRead and AsyncWrite</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> TODO: Asynchronous Design Patterns: Solutions and Suggestions</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> TODO: Modeling Servers and the Request/Response Pattern</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.2.</strong> TODO: Managing Shared State</div></li></ol></li><li class="chapter-item expanded "><a href="../12_appendix/01_translations.html"><strong aria-hidden="true">12.</strong> Annexe : traductions du livre</a></li><li class="chapter-item expanded affix "><a href="../translation-terms.html">Traduction des termes</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">La programmation asynchrone avec Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Jimskapt/async-book-fr/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<h1 id="-attention-peinture-fraÃ®che-"><a class="header" href="#-attention-peinture-fraÃ®che-">ğŸš§ Attention, peinture fraÃ®che !</a></h1>
<p>Cette page a Ã©tÃ© traduite par une seule personne et n'a pas Ã©tÃ© relue et
vÃ©rifiÃ©e par quelqu'un d'autre ! Les informations peuvent par exemple Ãªtre
erronÃ©es, Ãªtre formulÃ©es maladroitement, ou contenir d'autres types de fautes.</p>
<p>Vous pouvez contribuer Ã  l'amÃ©lioration de cette page sur sa
<a href="https://github.com/Jimskapt/async-book-fr/pull/6">Pull Request</a>.</p>
</blockquote>
<!--
# `async`/`.await`
-->
<h1 id="async-et-await"><a class="header" href="#async-et-await"><code>async</code> et <code>await</code></a></h1>
<!--
In [the first chapter], we took a brief look at `async`/`.await`.
This chapter will discuss `async`/`.await` in
greater detail, explaining how it works and how `async` code differs from
traditional Rust programs.
-->
<p>Dans <a href="../01_getting_started/04_async_await_primer.html">le premier chapitre</a>, nous avons prÃ©sentÃ© <code>async</code> et
<code>await</code>. Ce nouveau chapitre va aborder plus en dÃ©tails <code>async</code> et <code>await</code>, en
expliquant comment il fonctionne et comment le code <code>async</code> se distingue des
programmes Rust traditionnels.</p>
<!--
`async`/`.await` are special pieces of Rust syntax that make it possible to
yield control of the current thread rather than blocking, allowing other
code to make progress while waiting on an operation to complete.
-->
<p><code>async</code> et <code>await</code> sont des mot-clÃ©s spÃ©cifiques de la syntaxe Rust qui permet
de transfÃ©rer le contrÃ´le du processus en cours plutÃ´t que de le bloquer,
ce qui permet Ã  un autre code de progresser pendant que nous attendons que
cette opÃ©ration se termine.</p>
<!--
There are two main ways to use `async`: `async fn` and `async` blocks.
Each returns a value that implements the `Future` trait:
-->
<p>Il y a deux principaux moyens d'utiliser <code>async</code>Â : <code>async fn</code> et les blocs
<code>async</code>. Chacun retourne une valeur qui implÃ©mente le trait <code>Future</code>Â :</p>
<!--
```rust,edition2018,ignore

// `foo()` returns a type that implements `Future<Output = u8>`.
// `foo().await` will result in a value of type `u8`.
async fn foo() -> u8 { 5 }

fn bar() -> impl Future<Output = u8> {
    // This `async` block results in a type that implements
    // `Future<Output = u8>`.
    async {
        let x: u8 = foo().await;
        x + 5
    }
}
```
-->
<pre><code class="language-rust edition2018 ignore">
// `alpha()` retourne un type qui implÃ©mente `Future&lt;Output = u8&gt;`.
// `alpha().await` va retourner une valeur de type `u8`.
async fn alpha() -&gt; u8 { 5 }

fn beta() -&gt; impl Future&lt;Output = u8&gt; {
    // Ce bloc `async` va retourner un type qui implÃ©mente
    // `Future&lt;Output = u8&gt;`.
    async {
        let x: u8 = alpha().await;
        x + 5
    }
}
</code></pre>
<!--
As we saw in the first chapter, `async` bodies and other futures are lazy:
they do nothing until they are run. The most common way to run a `Future`
is to `.await` it. When `.await` is called on a `Future`, it will attempt
to run it to completion. If the `Future` is blocked, it will yield control
of the current thread. When more progress can be made, the `Future` will be picked
up by the executor and will resume running, allowing the `.await` to resolve.
-->
<p>Comme nous l'avons vu dans le premier chapitre, les corps des <code>async</code> et des
autres futures sont passifsÂ : ils ne font rien jusqu'Ã  ce qu'ils soient
exÃ©cutÃ©s. La faÃ§on la plus courante d'exÃ©cuter une <code>Future</code> est d'utiliser
<code>await</code> sur elle. Lorsque <code>await</code> est utilisÃ© sur une <code>Future</code>, il va tenter de
l'exÃ©cuter jusqu'Ã  sa fin. Si la <code>Future</code> est bloquÃ©e, il va transfÃ©rer le
contrÃ´le du processus en cours. Lorsqu'une progression pourra Ãªtre effectuÃ©e Ã 
nouveau, la <code>Future</code> va Ãªtre rÃ©cupÃ©rÃ©e par l'exÃ©cuteur et va continuer son
exÃ©cution, ce qui permettra Ã  terme au <code>await</code> de se rÃ©soudre.</p>
<!--
## `async` Lifetimes
-->
<h2 id="les-durÃ©es-de-vie-async"><a class="header" href="#les-durÃ©es-de-vie-async">Les durÃ©es de vie <code>async</code></a></h2>
<!--
Unlike traditional functions, `async fn`s which take references or other
non-`'static` arguments return a `Future` which is bounded by the lifetime of
the arguments:
-->
<p>Contrairement aux fonctions traditionnelles, les <code>async fn</code> qui utilisent des
rÃ©fÃ©rences ou d'autres arguments non <code>static</code> vont retourner une <code>Future</code> qui
est contrainte par la durÃ©e de vie des argumentsÂ :</p>
<!--
```rust,edition2018,ignore
// This function:
async fn foo(x: &u8) -> u8 { *x }

// Is equivalent to this function:
fn foo_expanded<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {
    async move { *x }
}
```
-->
<pre><code class="language-rust edition2018 ignore">// Cette fonctionÂ :
async fn alpha(x: &amp;u8) -&gt; u8 { *x }

// ... est Ã©quivalente Ã  cette fonctionÂ :
fn alpha_enrichi&lt;'a&gt;(x: &amp;'a u8) -&gt; impl Future&lt;Output = u8&gt; + 'a {
    async move { *x }
}
</code></pre>
<!--
This means that the future returned from an `async fn` must be `.await`ed
while its non-`'static` arguments are still valid. In the common
case of `.await`ing the future immediately after calling the function
(as in `foo(&x).await`) this is not an issue. However, if storing the future
or sending it over to another task or thread, this may be an issue.
-->
<p>Cela signifie que l'on doit utiliser <code>await</code> sur la future retournÃ©e d'une
<code>async fn</code> uniquement pendant que ses arguments non <code>static</code> sont toujours en
vigueur. Dans le cas courant oÃ¹ on utilise <code>await</code> sur la future immÃ©diatement
aprÃ¨s avoir appelÃ© la fonction (comme avec <code>alpha(&amp;x).await</code>), ce n'est pas un
problÃ¨me. Cependant, si on stocke la future ou si on l'envoie Ã  une autre tÃ¢che
ou processus, cela peut devenir un problÃ¨me.</p>
<!--
One common workaround for turning an `async fn` with references-as-arguments
into a `'static` future is to bundle the arguments with the call to the
`async fn` inside an `async` block:
-->
<p>Un contournement courant pour utiliser une <code>async fn</code> avec des rÃ©fÃ©rences en
argument afin qu'elle retourne une future <code>'static</code> est d'envelopper Ã 
l'intÃ©rieur d'un bloc <code>async</code> les arguments utilisÃ©s pour l'appel Ã  la
<code>async fn</code>Â :</p>
<!--
```rust,edition2018,ignore
fn bad() -> impl Future<Output = u8> {
    let x = 5;
    borrow_x(&x) // ERROR: `x` does not live long enough
}

fn good() -> impl Future<Output = u8> {
    async {
        let x = 5;
        borrow_x(&x).await
    }
}
```
-->
<pre><code class="language-rust edition2018 ignore">fn incorrect() -&gt; impl Future&lt;Output = u8&gt; {
    let x = 5;
    emprunter_x(&amp;x) // ERREUR : `x` ne vit pas suffisamment longtemps
}

fn correct() -&gt; impl Future&lt;Output = u8&gt; {
    async {
        let x = 5;
        emprunter_x(&amp;x).await
    }
}
</code></pre>
<!--
By moving the argument into the `async` block, we extend its lifetime to match
that of the `Future` returned from the call to `good`.
-->
<p>En dÃ©plaÃ§ant l'argument dans le bloc <code>async</code>, nous avons Ã©tendu sa durÃ©e de vie
Ã  celle de cette <code>Future</code> qui est retournÃ©e suite Ã  l'appel Ã  <code>correct</code>.</p>
<!--
## `async move`
-->
<h2 id="async-move"><a class="header" href="#async-move"><code>async move</code></a></h2>
<!--
`async` blocks and closures allow the `move` keyword, much like normal
closures. An `async move` block will take ownership of the variables it
references, allowing it to outlive the current scope, but giving up the ability
to share those variables with other code:
-->
<p>Les blocs et fermetures <code>async</code>autorisent l'utilisation du mot-clÃ© <code>move</code>,
comme les fermetures synchrones. Un bloc <code>async move</code> va prendre possession
des variables qu'il utilise, leur permettant de survivre Ã  l'extÃ©rieur de la
portÃ©e actuelle, mais par consÃ©quent qui empÃªche de partager ces variables avec
un autre codeÂ :</p>
<!--
```rust,edition2018,ignore
/// `async` block:
///
/// Multiple different `async` blocks can access the same local variable
/// so long as they're executed within the variable's scope
async fn blocks() {
    let my_string = "foo".to_string();

    let future_one = async {
        // ...
        println!("{my_string}");
    };

    let future_two = async {
        // ...
        println!("{my_string}");
    };

    // Run both futures to completion, printing "foo" twice:
    let ((), ()) = futures::join!(future_one, future_two);
}

/// `async move` block:
///
/// Only one `async move` block can access the same captured variable, since
/// captures are moved into the `Future` generated by the `async move` block.
/// However, this allows the `Future` to outlive the original scope of the
/// variable:
fn move_block() -> impl Future<Output = ()> {
    let my_string = "foo".to_string();
    async move {
        // ...
        println!("{my_string}");
    }
}
```
-->
<pre><code class="language-rust edition2018 ignore">/// blocs `async`Â :
///
/// Plusieurs blocs `async` diffÃ©rents peuvent accÃ©der Ã  la mÃªme variable
/// locale tant qu'elles sont exÃ©cutÃ©es dans la portÃ©e de la variable
async fn blocs() {
    let ma_chaine = &quot;alpha&quot;.to_string();

    let premiere_future = async {
        // ...
        println!(&quot;{ma_chaine}&quot;);
    };

    let seconde_future = async {
        // ...
        println!(&quot;{ma_chaine}&quot;);
    };

    // ExÃ©cute les deux futures jusqu'Ã  leur fin, ce qui affichera
    // deux fois &quot;alpha&quot;Â :
    let ((), ()) = futures::join!(premiere_future, seconde_future);
}

/// blocs `async move`Â :
///
/// Un seul bloc `async move` peut avoir accÃ¨s Ã  la mÃªme variable capturÃ©e,
/// puisque qu'elles sont dÃ©placÃ©es dans la `Future` gÃ©nÃ©rÃ©e par le bloc
/// `async move`.
/// Cependant, cela permet d'Ã©tendre la portÃ©e de la `Future` en dehors de
/// celle de la variableÂ :
fn bloc_avec_move() -&gt; impl Future&lt;Output = ()&gt; {
    let ma_chaine = &quot;alpha&quot;.to_string();
    async move {
        // ...
        println!(&quot;{ma_chaine}&quot;);
    }
}
</code></pre>
<!--
## `.await`ing on a Multithreaded Executor
-->
<h2 id="utiliser-await-avec-un-exÃ©cuteur-multi-processus"><a class="header" href="#utiliser-await-avec-un-exÃ©cuteur-multi-processus">Utiliser <code>await</code> avec un exÃ©cuteur multi-processus</a></h2>
<!--
Note that, when using a multithreaded `Future` executor, a `Future` may move
between threads, so any variables used in `async` bodies must be able to travel
between threads, as any `.await` can potentially result in a switch to a new
thread.
-->
<p>Remarquez que lorsque vous utilisez un exÃ©cuteur de <code>Future</code> multi-processus,
une <code>Future</code> peut Ãªtre dÃ©placÃ©e entre les processus, donc toutes les variables
utilisÃ©es dans les corps des <code>async</code> doivent pouvoir aussi Ãªtre dÃ©placÃ©s entre
des processus, car n'importe quel <code>await</code> peut potentiellement basculer sur un
autre processus.</p>
<!--
This means that it is not safe to use `Rc`, `&RefCell` or any other types
that don't implement the `Send` trait, including references to types that don't
implement the `Sync` trait.
-->
<p>Cela signifie que ce n'est sÃ»r d'utiliser <code>Rc</code>, <code>&amp;RefCell</code> ou tout autre type
qui n'implÃ©mente pas le trait <code>Send</code>, y compris les rÃ©fÃ©rences Ã  des types qui
n'implÃ©mente pas le trait <code>Sync</code>.</p>
<!--
(Caveat: it is possible to use these types as long as they aren't in scope
during a call to `.await`.)
-->
<p>(Remarque : il reste possible d'utiliser ces types du moment qu'ils ne sont pas
dans la portÃ©e d'un appel Ã  <code>await</code>)</p>
<!--
Similarly, it isn't a good idea to hold a traditional non-futures-aware lock
across an `.await`, as it can cause the threadpool to lock up: one task could
take out a lock, `.await` and yield to the executor, allowing another task to
attempt to take the lock and cause a deadlock. To avoid this, use the `Mutex`
in `futures::lock` rather than the one from `std::sync`.
-->
<p>Pour la mÃªme raison, ce n'est pas une bonne idÃ©e de maintenir un verrou
traditionnel, qui ne se prÃ©occupe pas des futures, dans un <code>await</code>, car cela
peut provoquer le blocage du groupe de processusÂ : une tÃ¢che peut poser le
verrou, attendre grÃ¢ce Ã  <code>await</code> et transfÃ©rer le contrÃ´le Ã  l'exÃ©cuteur, qui
va permettre Ã  une autre tÃ¢che de vouloir poser le verrou et cela va causer un
interblocage. Pour Ã©viter cela, utilisez le <code>Mutex</code> dans <code>futures::lock</code> plutÃ´t
que celui dans <code>std::sync</code>.</p>
<!--
[the first chapter]: ../01_getting_started/04_async_await_primer.md
-->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../02_execution/05_io.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../04_pinning/01_chapter.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../02_execution/05_io.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../04_pinning/01_chapter.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
