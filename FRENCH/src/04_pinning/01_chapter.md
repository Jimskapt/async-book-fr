> # üöß Attention, peinture fra√Æche !
>
> Cette page a √©t√© traduite par une seule personne et n'a pas √©t√© relue et
> v√©rifi√©e par quelqu'un d'autre ! Les informations peuvent par exemple √™tre
> erron√©es, √™tre formul√©es maladroitement, ou contenir d'autres types de fautes.
>
> Vous pouvez contribuer √† l'am√©lioration de cette page sur sa
> [Pull Request](https://github.com/Jimskapt/async-book-fr/pull/7).

<!--
# Pinning
-->

# L'√©pinglage

<!--
To poll futures, they must be pinned using a special type called
`Pin<T>`. If you read the explanation of [the `Future` trait] in the
previous section ["Executing `Future`s and Tasks"], you'll recognize
`Pin` from the `self: Pin<&mut Self>` in the `Future::poll` method's definition.
But what does it mean, and why do we need it?
-->

Pour piloter les futures, ils doivent √™tre √©pingl√©s en utilisant un type
sp√©cial qui s'appelle `Pin<T>`. Si vous lisez l'explication [du trait
`Future`][the `Future` trait] dans la [section pr√©c√©dente]["Executing `Future`s
and Tasks"], vous devriez constater la pr√©sence du `Pin` dans le
`self: Pin<&mut Self>` dans la d√©finition de la m√©thode `Future::poll`. Mais
qu'est-ce que cela signifie, et pourquoi nous en avons besoin¬†?

<!--
## Why Pinning
-->

## Pourquoi √©pingler ?

<!--
`Pin` works in tandem with the `Unpin` marker. Pinning makes it possible
to guarantee that an object implementing `!Unpin` won't ever be moved. To understand
why this is necessary, we need to remember how `async`/`.await` works. Consider
the following code:
-->

`Pin` fonctionne en bin√¥me avec le marqueur `Unpin`. L'√©pinglage permet de
garantir qu'un objet qui impl√©mente `!Unpin` ne sera jamais d√©plac√©. Pour
comprendre pourquoi c'est n√©cessaire, nous devons nous rappeler comment `async`
et `await` fonctionnent. Imaginons le code suivant¬†:

<!--
```rust,edition2018,ignore
let fut_one = /* ... */;
let fut_two = /* ... */;
async move {
    fut_one.await;
    fut_two.await;
}
```
-->

```rust,edition2018,ignore
let premiere_future = /* ... */;
let seconde_future = /* ... */;
async move {
    premiere_future.await;
    seconde_future.await;
}
```

<!--
Under the hood, this creates an anonymous type that implements `Future`,
providing a `poll` method that looks something like this:
-->

Sous le capot, cela cr√©e un type anonyme qui impl√©mente `Future`, ce qui va
fournir une m√©thode `poll` qui ressemble √† ceci¬†:

<!--
```rust,ignore
// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// List of states our `async` block can be in
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => match self.fut_one.poll(..) {
                    Poll::Ready(()) => self.state = State::AwaitingFutTwo,
                    Poll::Pending => return Poll::Pending,
                }
                State::AwaitingFutTwo => match self.fut_two.poll(..) {
                    Poll::Ready(()) => self.state = State::Done,
                    Poll::Pending => return Poll::Pending,
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}
```
-->

```rust,ignore
// Le type `Future` g√©n√©r√© pour notre bloc `async { ... }`
struct FutureAsynchrone {
    premiere_future: FutOne,
    seconde_future: FutTwo,
    etat: Etat,
}

// Liste des √©tats dans lesquels notre bloc `async` peut √™tre
enum Etat {
    AttentePremiereFuture,
    AttenteSecondeFuture,
    Termine,
}

impl Future for FutureAsynchrone {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.etat {
                Etat::AttentePremiereFuture => match self.premiere_future.poll(..) {
                    Poll::Ready(()) => self.etat = Etat::AttenteSecondeFuture,
                    Poll::Pending => return Poll::Pending,
                }
                Etat::AttenteSecondeFuture => match self.seconde_future.poll(..) {
                    Poll::Ready(()) => self.etat = Etat::Termine,
                    Poll::Pending => return Poll::Pending,
                }
                Etat::Termine => return Poll::Ready(()),
            }
        }
    }
}
```

<!--

When `poll` is first called, it will poll `fut_one`. If `fut_one` can't
complete, `AsyncFuture::poll` will return. Future calls to `poll` will pick
up where the previous one left off. This process continues until the future
is able to successfully complete.
-->

Lorsque `poll` est appel√© la premi√®re fois, il va appeler `premiere_future`. Si
`premiere_future` ne peut pas √™tre compl√©t√©, `FutureAsynchrone::poll` va retourner
sa valeur. Les appels futurs √† `poll` vont reprendre o√π le pr√©c√©dent s'est
arr√™t√©. Ce fonctionnement va continuer jusqu'√† ce que la future se termine au
complet.

<!--
However, what happens if we have an `async` block that uses references?
For example:
-->

Cependant, que se passe-t-il si nous avons un bloc `async` qui utilise des
r√©f√©rences¬†? Par exemple¬†:

<!--
```rust,edition2018,ignore
async {
    let mut x = [0; 128];
    let read_into_buf_fut = read_into_buf(&mut x);
    read_into_buf_fut.await;
    println!("{:?}", x);
}
```
-->

```rust,edition2018,ignore
async {
    let mut x = [0; 128];
    let lire_dans_un_tampon = lire_dans_un_tampon(&mut x);
    lire_dans_un_tampon.await;
    println!("{:?}", x);
}
```

<!--
What struct does this compile down to?
-->

Quelle structure va donner la compilation¬†?

<!--
```rust,ignore
struct ReadIntoBuf<'a> {
    buf: &'a mut [u8], // points to `x` below
}

struct AsyncFuture {
    x: [u8; 128],
    read_into_buf_fut: ReadIntoBuf<'what_lifetime?>,
}
```
-->

```rust,ignore
struct LireDansTampon<'a> {
    tampon: &'a mut [u8], // cela pointe sur le `x` ci-desous
}

struct FutureAsynchrone {
    x: [u8; 128],
    future_lire_dans_un_tampon: LireDansTampon<'quelle_duree_de_vie?>,
}
```

<!--
Here, the `ReadIntoBuf` future holds a reference into the other field of our
structure, `x`. However, if `AsyncFuture` is moved, the location of `x` will
move as well, invalidating the pointer stored in `read_into_buf_fut.buf`.
-->

Ici, la future `LireDansTampon` contient une r√©f√©rence vers l'autre champ de
notre structure, `x`. Cependant, si `FutureAsynchrone` est d√©plac√©e,
l'emplacement de `x` va aussi √™tre d√©plac√©, ce qui va corrompre le pointeur
stock√© dans `future_lire_dans_un_tampon.tampon`.

<!--
Pinning futures to a particular spot in memory prevents this problem, making
it safe to create references to values inside an `async` block.
-->

L'√©pinglage des futures √† un endroit pr√©cis de la m√©moire √©vite ce probl√®me, ce
qui va s√©curiser la cr√©ation de r√©f√©rences vers des valeurs dans des blocs
`async`.

<!--
## Pinning in Detail
-->

## L'√©pinglage en d√©tail

<!--
Let's try to understand pinning by using an slightly simpler example. The problem we encounter
above is a problem that ultimately boils down to how we handle references in self-referential
types in Rust.
-->

Essayons de comprendre l'√©pinglage en utilisant un exemple l√©g√®rement plus
simple. Le probl√®me que nous allons rencontrer ci-dessous peut se r√©sumer √†
notre mani√®re de g√©rer les types auto-r√©f√©rentiels en Rust.

<!--
For now our example will look like this:
-->

Pour l'instant, notre exemple ressemble √† ceci¬†:

<!--
```rust, ignore
#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
        }
    }

    fn init(&mut self) {
        let self_ref: *const String = &self.a;
        self.b = self_ref;
    }

    fn a(&self) -> &str {
        &self.a
    }

    fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```
-->

```rust, ignore
#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
}

impl Test {
    fn new(texte: &str) -> Self {
        Test {
            a: String::from(texte),
            b: std::ptr::null(),
        }
    }

    fn initialiser(&mut self) {
        let self_ref: *const String = &self.a;
        self.b = self_ref;
    }

    fn a(&self) -> &str {
        &self.a
    }

    fn b(&self) -> &String {
        assert!(!self.b.is_null(), "Test::b est appel√© sans appeler avant Test::initialiser");
        unsafe { &*(self.b) }
    }
}
```

<!--
`Test` provides methods to get a reference to the value of the fields `a` and `b`. Since `b` is a
reference to `a` we store it as a pointer since the borrowing rules of Rust doesn't allow us to
define this lifetime. We now have what we call a self-referential struct.
-->

`Test` propose des m√©thodes pour obtenir une r√©f√©rence vers la valeur des
champs `a` et `b`. Comme `b` est une r√©f√©rence vers `a`, nous le stockons comme
un pointeur puisque les r√®gles d'emprunt de Rust ne nous autorisent pas √†
d√©finir cette dur√©e de vie. Nous avons d√©sormais ce que l'on appelle une
structure auto-r√©f√©rentielle.

<!--
Our example works fine if we don't move any of our data around as you can observe by running
this example:
-->

Notre exemple fonctionne bien si nous ne d√©pla√ßons aucune de nos donn√©es, comme
vous pouvez le constater en ex√©cutant cet exemple¬†:

<!--
```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    println!("a: {}, b: {}", test2.a(), test2.b());

}
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
# }
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#         }
#     }
#
#     // We need an `init` method to actually set our self-reference
#     fn init(&mut self) {
#         let self_ref: *const String = &self.a;
#         self.b = self_ref;
#     }
#
#     fn a(&self) -> &str {
#         &self.a
#     }
#
#     fn b(&self) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```
-->

```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.initialiser();
    let mut test2 = Test::new("test2");
    test2.initialiser();

    println!("a: {}, b: {}", test1.a(), test1.b());
    println!("a: {}, b: {}", test2.a(), test2.b());

}
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
# }
#
# impl Test {
#     fn new(texte: &str) -> Self {
#         Test {
#             a: String::from(texte),
#             b: std::ptr::null(),
#         }
#     }
#
#     // We need an `init` method to actually set our self-reference
#     fn initialiser(&mut self) {
#         let self_ref: *const String = &self.a;
#         self.b = self_ref;
#     }
#
#     fn a(&self) -> &str {
#         &self.a
#     }
#
#     fn b(&self) -> &String {
#         assert!(!self.b.is_null(), "Test::b est appel√© sans appeler avant Test::initialiser");
#         unsafe { &*(self.b) }
#     }
# }
```

<!--
We get what we'd expect:
-->

Nous obtenons ce que nous attendions¬†:

<!--
```rust, ignore
a: test1, b: test1
a: test2, b: test2
```
-->

```rust, ignore
a: test1, b: test1
a: test2, b: test2
```

<!--
Let's see what happens if we swap `test1` with `test2` and thereby move the data:
-->

Voyons maintenant ce qui se passe si nous permutions `test1` avec `test2` et
ainsi nous d√©pla√ßons les donn√©es¬†:

<!--
```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    println!("a: {}, b: {}", test2.a(), test2.b());

}
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
# }
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#         }
#     }
#
#     fn init(&mut self) {
#         let self_ref: *const String = &self.a;
#         self.b = self_ref;
#     }
#
#     fn a(&self) -> &str {
#         &self.a
#     }
#
#     fn b(&self) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```
-->

```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.initialiser();
    let mut test2 = Test::new("test2");
    test2.initialiser();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    println!("a: {}, b: {}", test2.a(), test2.b());

}
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
# }
#
# impl Test {
#     fn new(texte: &str) -> Self {
#         Test {
#             a: String::from(texte),
#             b: std::ptr::null(),
#         }
#     }
#
#     fn initialiser(&mut self) {
#         let self_ref: *const String = &self.a;
#         self.b = self_ref;
#     }
#
#     fn a(&self) -> &str {
#         &self.a
#     }
#
#     fn b(&self) -> &String {
#         assert!(!self.b.is_null(), "Test::b est appel√© sans appeler avant Test::initialiser");
#         unsafe { &*(self.b) }
#     }
# }
```

<!--
Naively, we could think that what we should get a debug print of `test1` two times like this:
-->

Na√Øvement, nous pourrions penser que nous devrions obtenir l'√©criture de
d√©boguage de `test1` deux fois comme ceci¬†:

<!--
```rust, ignore
a: test1, b: test1
a: test1, b: test1
```
-->

```rust, ignore
a: test1, b: test1
a: test1, b: test1
```

<!--
But instead we get:
-->

Mais √† la place, nous avons ceci¬†:

<!--
```rust, ignore
a: test1, b: test1
a: test1, b: test2
```
-->

```rust, ignore
a: test1, b: test1
a: test1, b: test2
```

<!--
The pointer to `test2.b` still points to the old location which is inside `test1`
now. The struct is not self-referential anymore, it holds a pointer to a field
in a different object. That means we can't rely on the lifetime of `test2.b` to
be tied to the lifetime of `test2` anymore.
-->

Le pointeur vers `test2.b` pointe toujours vers l'ancien emplacement qui est
maintenant `test1`. La structure n'est plus auto-r√©f√©rentielle, elle contient
un pointeur vers un champ dans un objet diff√©rent. Cela signifie que nous ne
pouvons plus consid√©rer que la dur√©e de vie de `test2.b` soit toujours li√©e √†
la dur√©e de vie de `test2`.

<!--
If you're still not convinced, this should at least convince you:
-->

Si vous n'√™tes pas convaincu, ceci devrait vous convaincre¬†:

<!--
```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.init();
    let mut test2 = Test::new("test2");
    test2.init();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    test1.a = "I've totally changed now!".to_string();
    println!("a: {}, b: {}", test2.a(), test2.b());

}
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
# }
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#         }
#     }
#
#     fn init(&mut self) {
#         let self_ref: *const String = &self.a;
#         self.b = self_ref;
#     }
#
#     fn a(&self) -> &str {
#         &self.a
#     }
#
#     fn b(&self) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```
-->

```rust
fn main() {
    let mut test1 = Test::new("test1");
    test1.initialiser();
    let mut test2 = Test::new("test2");
    test2.initialiser();

    println!("a: {}, b: {}", test1.a(), test1.b());
    std::mem::swap(&mut test1, &mut test2);
    test1.a = "J'ai compl√®tement chang√©, d√©sormais¬†!".to_string();
    println!("a: {}, b: {}", test2.a(), test2.b());

}
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
# }
#
# impl Test {
#     fn new(texte: &str) -> Self {
#         Test {
#             a: String::from(texte),
#             b: std::ptr::null(),
#         }
#     }
#
#     fn initialiser(&mut self) {
#         let self_ref: *const String = &self.a;
#         self.b = self_ref;
#     }
#
#     fn a(&self) -> &str {
#         &self.a
#     }
#
#     fn b(&self) -> &String {
#         assert!(!self.b.is_null(), "Test::b est appel√© sans appeler avant Test::initialiser");
#         unsafe { &*(self.b) }
#     }
# }
```

<!--
The diagram below can help visualize what's going on:
-->

Le sch√©ma ci-dessous peut vous aider √† voir ce qui se passe¬†:

<!--
**Fig 1: Before and after swap**
![swap_problem](../assets/swap_problem.jpg)
-->

**Figure 1¬†: avant et apr√®s l'√©change**
![probleme_echange](../assets/swap_problem.jpg)

<!--
It's easy to get this to show undefined behavior and fail in other spectacular ways as well.
-->

C'est ainsi facile d'avoir un fonctionnement ind√©fini et aussi de provoquer une
autre d√©faillance spectaculaire.

<!--
## Pinning in Practice
-->

## L'√©pinglage dans la pratique

<!--
Let's see how pinning and the `Pin` type can help us solve this problem.
-->

Voyons voir comment l'√©pinglage et le type `Pin` peut nous aider √† r√©soudre ce
probl√®me.

<!--
The `Pin` type wraps pointer types, guaranteeing that the values behind the
pointer won't be moved. For example, `Pin<&mut T>`, `Pin<&T>`,
`Pin<Box<T>>` all guarantee that `T` won't be moved even if `T: !Unpin`.
-->

Le type `Pin` enveloppe les types de pointeurs, ce qui garantit que les valeurs
derri√®re ce pointeur ne seront pas d√©plac√©es. Par exemple, `Pin<&mut T>`,
`Pin<&T>`, `Pin<Box<T>>` garantissent tous que `T` ne sera pas d√©plac√© m√™me si
`T: !Unpin`.

<!--
Most types don't have a problem being moved. These types implement a trait
called `Unpin`. Pointers to `Unpin` types can be freely placed into or taken
out of `Pin`. For example, `u8` is `Unpin`, so `Pin<&mut u8>` behaves just like
a normal `&mut u8`.
-->

La plupart des types n'ont pas de probl√®me lorsqu'ils sont d√©plac√©s. Ces types
impl√©mentent le trait `Unpin`. Les pointeurs vers des types `Unpin` peuvent
√™tre librement log√©s √† l'int√©rieur d'un `Pin`, ou en √™tre retir√©. Par exemple,
`u8` impl√©mente `Unpin`, donc `Pin<&mut u8>` se comporte exactement comme un
`&mut u8` normal.

<!--
However, types that can't be moved after they're pinned have a marker called
`!Unpin`. Futures created by async/await is an example of this.
-->

Cependant, les types qui ne peuvent pas √™tre d√©plac√©s apr√®s avoir √©t√© √©pingl√©s
ont un marqueur `!Unpin`. Les futures cr√©√©es par `async` et `await` en sont un
exemple.

<!--
### Pinning to the Stack
-->

### L'√©pinglage sur la pile

<!--
Back to our example. We can solve our problem by using `Pin`. Let's take a look at what
our example would look like if we required a pinned pointer instead:
-->

Retournons √† notre exemple. Nous pouvons r√©soudre notre probl√®me en utilisant
`Pin`. Voyons ce √† quoi notre exemple ressemblerait si nous avions utilis√© un
pointeur √©pingl√© √† la place¬†:

<!-- markdownlint-disable -->
<!--
```rust, ignore
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}


impl Test {
    fn new(txt: &str) -> Self {
        Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned, // This makes our type `!Unpin`
        }
    }

    fn init(self: Pin<&mut Self>) {
        let self_ptr: *const String = &self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_ptr;
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
        unsafe { &*(self.b) }
    }
}
```
-->
<!-- markdownlint-enable -->

```rust, ignore
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marqueur: PhantomPinned,
}

impl Test {
    fn new(texte: &str) -> Self {
        Test {
            a: String::from(texte),
            b: std::ptr::null(),
            _marqueur: PhantomPinned, // Cela rends notre type `!Unpin`
        }
    }

    fn initialiser(self: Pin<&mut Self>) {
        let self_pointeur: *const String = &self.a;
        let this = unsafe { self.get_unchecked_mut() };
        this.b = self_pointeur;
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        assert!(!self.b.is_null(), "Test::b est appel√© sans appeler avant Test::initialiser");
        unsafe { &*(self.b) }
    }
}
```

<!--
Pinning an object to the stack will always be `unsafe` if our type implements
`!Unpin`. You can use a crate like [`pin_utils`][pin_utils] to avoid writing
our own `unsafe` code when pinning to the stack.
-->

L'√©pinglage d'un objet √† la pile va toujours √™tre `unsafe` si notre type
impl√©mente `!Unpin`. Vous pouvez utiliser une crate comme
[`pin_utils`][pin_utils] pour √©viter d'avoir √† √©crire notre propre `unsafe` code
lorsqu'on √©pinglera sur la pile.

<!--
Below, we pin the objects `test1` and `test2` to the stack:
-->

Ci-dessous, nous √©pinglons les objets `test1` et `test2` sur la pile¬†:

<!--
```rust
pub fn main() {
    // test1 is safe to move before we initialize it
    let mut test1 = Test::new("test1");
    // Notice how we shadow `test1` to prevent it from being accessed again
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
# use std::pin::Pin;
# use std::marker::PhantomPinned;
#
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
#     _marker: PhantomPinned,
# }
#
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#             // This makes our type `!Unpin`
#             _marker: PhantomPinned,
#         }
#     }
#
#     fn init(self: Pin<&mut Self>) {
#         let self_ptr: *const String = &self.a;
#         let this = unsafe { self.get_unchecked_mut() };
#         this.b = self_ptr;
#     }
#
#     fn a(self: Pin<&Self>) -> &str {
#         &self.get_ref().a
#     }
#
#     fn b(self: Pin<&Self>) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```
-->

```rust
pub fn main() {
    // test1 peut √™tre d√©plac√© en s√©curit√© avant que nous l'initialisions¬†:
    let mut test1 = Test::new("test1");
    // Notez que nous masquons `test1` pour l'emp√™cher d'√™tre toujours
    // accessible :
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::initialiser(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::initialiser(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
# use std::pin::Pin;
# use std::marker::PhantomPinned;
#
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
#     _marqueur: PhantomPinned,
# }
#
#
# impl Test {
#     fn new(texte: &str) -> Self {
#         Test {
#             a: String::from(texte),
#             b: std::ptr::null(),
#             // Cela rends notre type `!Unpin`
#             _marqueur: PhantomPinned,
#         }
#     }
#
#     fn initialiser(self: Pin<&mut Self>) {
#         let self_pointeur: *const String = &self.a;
#         let this = unsafe { self.get_unchecked_mut() };
#         this.b = self_pointeur;
#     }
#
#     fn a(self: Pin<&Self>) -> &str {
#         &self.get_ref().a
#     }
#
#     fn b(self: Pin<&Self>) -> &String {
#         assert!(!self.b.is_null(), "Test::b est appel√© sans appeler avant Test::initialiser");
#         unsafe { &*(self.b) }
#     }
# }
```

<!--
Now, if we try to move our data now we get a compilation error:
-->

Maintenant, si nous essayons de d√©placer nos donn√©es, nous avons d√©sormais une
erreur de compilation¬†:

<!--
```rust, compile_fail
pub fn main() {
    let mut test1 = Test::new("test1");
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::init(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::init(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
# use std::pin::Pin;
# use std::marker::PhantomPinned;
#
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
#     _marker: PhantomPinned,
# }
#
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#             _marker: PhantomPinned, // This makes our type `!Unpin`
#         }
#     }
#
#     fn init(self: Pin<&mut Self>) {
#         let self_ptr: *const String = &self.a;
#         let this = unsafe { self.get_unchecked_mut() };
#         this.b = self_ptr;
#     }
#
#     fn a(self: Pin<&Self>) -> &str {
#         &self.get_ref().a
#     }
#
#     fn b(self: Pin<&Self>) -> &String {
#         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
#         unsafe { &*(self.b) }
#     }
# }
```
-->

```rust, compile_fail
pub fn main() {
    let mut test1 = Test::new("test1");
    let mut test1 = unsafe { Pin::new_unchecked(&mut test1) };
    Test::initialiser(test1.as_mut());

    let mut test2 = Test::new("test2");
    let mut test2 = unsafe { Pin::new_unchecked(&mut test2) };
    Test::initialiser(test2.as_mut());

    println!("a: {}, b: {}", Test::a(test1.as_ref()), Test::b(test1.as_ref()));
    std::mem::swap(test1.get_mut(), test2.get_mut());
    println!("a: {}, b: {}", Test::a(test2.as_ref()), Test::b(test2.as_ref()));
}
# use std::pin::Pin;
# use std::marker::PhantomPinned;
#
# #[derive(Debug)]
# struct Test {
#     a: String,
#     b: *const String,
#     _marqueur: PhantomPinned,
# }
#
#
# impl Test {
#     fn new(txt: &str) -> Self {
#         Test {
#             a: String::from(txt),
#             b: std::ptr::null(),
#             _marqueur: PhantomPinned, // Cela rends notre type `!Unpin`
#         }
#     }
#
#     fn initialiser(self: Pin<&mut Self>) {
#         let self_pointeur: *const String = &self.a;
#         let this = unsafe { self.get_unchecked_mut() };
#         this.b = self_pointeur;
#     }
#
#     fn a(self: Pin<&Self>) -> &str {
#         &self.get_ref().a
#     }
#
#     fn b(self: Pin<&Self>) -> &String {
#         assert!(!self.b.is_null(), "Test::b est appel√© sans appeler avant Test::initialiser");
#         unsafe { &*(self.b) }
#     }
# }
```

<!--
The type system prevents us from moving the data.
-->

Le syst√®me de type nous emp√™che de d√©placer les donn√©es.

<!--
> It's important to note that stack pinning will always rely on guarantees
> you give when writing `unsafe`. While we know that the _pointee_ of `&'a mut T`
> is pinned for the lifetime of `'a` we can't know if the data `&'a mut T`
> points to isn't moved after `'a` ends. If it does it will violate the Pin
> contract.
>
> A mistake that is easy to make is forgetting to shadow the original variable
> since you could drop the `Pin` and move the data after `&'a mut T`
> like shown below (which violates the Pin contract):
>
> ```rust
> fn main() {
>    let mut test1 = Test::new("test1");
>    let mut test1_pin = unsafe { Pin::new_unchecked(&mut test1) };
>    Test::init(test1_pin.as_mut());
>
>    drop(test1_pin);
>    println!(r#"test1.b points to "test1": {:?}..."#, test1.b);
>
>    let mut test2 = Test::new("test2");
>    mem::swap(&mut test1, &mut test2);
>    println!("... and now it points nowhere: {:?}", test1.b);
> }
> # use std::pin::Pin;
> # use std::marker::PhantomPinned;
> # use std::mem;
> #
> # #[derive(Debug)]
> # struct Test {
> #     a: String,
> #     b: *const String,
> #     _marker: PhantomPinned,
> # }
> #
> #
> # impl Test {
> #     fn new(txt: &str) -> Self {
> #         Test {
> #             a: String::from(txt),
> #             b: std::ptr::null(),
> #             // This makes our type `!Unpin`
> #             _marker: PhantomPinned,
> #         }
> #     }
> #
> #     fn init<'a>(self: Pin<&'a mut Self>) {
> #         let self_ptr: *const String = &self.a;
> #         let this = unsafe { self.get_unchecked_mut() };
> #         this.b = self_ptr;
> #     }
> #
> #     fn a<'a>(self: Pin<&'a Self>) -> &'a str {
> #         &self.get_ref().a
> #     }
> #
> #     fn b<'a>(self: Pin<&'a Self>) -> &'a String {
> #         assert!(!self.b.is_null(), "Test::b called without Test::init being called first");
> #         unsafe { &*(self.b) }
> #     }
> # }
> ```
-->

> Il est important que vous compreniez que l'√©pinglage sur la pile s'appuie
> toujours sur les garanties que vous √©crivez dans votre `unsafe`. M√™me si nous
> savons que ce sur quoi pointe le `&'a mut T` est √©pingl√© pour la dur√©e de vie
> de `'a`, nous ne pouvons pas savoir si la donn√©e sur laquelle pointe
> `&'a mut T` n'est pas d√©plac√©e apr√®s que `'a` soit termin√©. Si c'est ce qui
> se passe, cela violera le contrat du `Pin`.
>
> Une erreur courante est d'oublier de masquer la variable originale alors que
> vous pourriez terminer le `Pin` et d√©placer la donn√©e apr√®s le `&'a mut T`
> comme nous le montrons ci-dessous (ce qui viole le contrat du `Pin`)¬†:
>
> ```rust
> fn main() {
>    let mut test1 = Test::new("test1");
>    let mut test1_pin = unsafe { Pin::new_unchecked(&mut test1) };
>    Test::init(test1_pin.as_mut());
>
>    drop(test1_pin);
>    println!(r#"test1.b pointe sur "test1": {:?}..."#, test1.b);
>
>    let mut test2 = Test::new("test2");
>    mem::swap(&mut test1, &mut test2);
>    println!("... et maintenant il pointe nulle part¬†: {:?}", test1.b);
> }
> # use std::pin::Pin;
> # use std::marker::PhantomPinned;
> # use std::mem;
> #
> # #[derive(Debug)]
> # struct Test {
> #     a: String,
> #     b: *const String,
> #     _marqueur: PhantomPinned,
> # }
> #
> #
> # impl Test {
> #     fn new(txt: &str) -> Self {
> #         Test {
> #             a: String::from(txt),
> #             b: std::ptr::null(),
> #             // Cela rends notre type `!Unpin`
> #             _marqueur: PhantomPinned,
> #         }
> #     }
> #
> #     fn init<'a>(self: Pin<&'a mut Self>) {
> #         let self_pointeur: *const String = &self.a;
> #         let this = unsafe { self.get_unchecked_mut() };
> #         this.b = self_pointeur;
> #     }
> #
> #     fn a<'a>(self: Pin<&'a Self>) -> &'a str {
> #         &self.get_ref().a
> #     }
> #
> #     fn b<'a>(self: Pin<&'a Self>) -> &'a String {
> #         assert!(!self.b.is_null(), "Test::b est appel√© sans appeler avant Test::initialiser");
> #         unsafe { &*(self.b) }
> #     }
> # }
> ```

<!--
### Pinning to the Heap
-->

### Epingler sur le tas

<!--
Pinning an `!Unpin` type to the heap gives our data a stable address so we know
that the data we point to can't move after it's pinned. In contrast to stack
pinning, we know that the data will be pinned for the lifetime of the object.
-->

L'√©pinglage d'un type `!Unpin` sur le tas donne une adresse stable √† vos
donn√©es donc nous savons que la donn√©e sur laquelle nous pointons ne peut pas
√™tre d√©plac√©e apr√®s avoir √©t√© √©pingl√©e. Contrairement √† l'√©pinglage sur la
pile, nous savons que la donn√©e va √™tre √©pingl√©e pendant la dur√©e de vie de
l'objet.

<!--
```rust, edition2018
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marker: PhantomPinned,
}

impl Test {
    fn new(txt: &str) -> Pin<Box<Self>> {
        let t = Test {
            a: String::from(txt),
            b: std::ptr::null(),
            _marker: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_ptr: *const String = &boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_ptr };

        boxed
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        unsafe { &*(self.b) }
    }
}

pub fn main() {
    let test1 = Test::new("test1");
    let test2 = Test::new("test2");

    println!("a: {}, b: {}",test1.as_ref().a(), test1.as_ref().b());
    println!("a: {}, b: {}",test2.as_ref().a(), test2.as_ref().b());
}
```
-->

```rust, edition2018
use std::pin::Pin;
use std::marker::PhantomPinned;

#[derive(Debug)]
struct Test {
    a: String,
    b: *const String,
    _marqueur: PhantomPinned,
}

impl Test {
    fn new(texte: &str) -> Pin<Box<Self>> {
        let t = Test {
            a: String::from(texte),
            b: std::ptr::null(),
            _marqueur: PhantomPinned,
        };
        let mut boxed = Box::pin(t);
        let self_pointeur: *const String = &boxed.as_ref().a;
        unsafe { boxed.as_mut().get_unchecked_mut().b = self_pointeur };

        boxed
    }

    fn a(self: Pin<&Self>) -> &str {
        &self.get_ref().a
    }

    fn b(self: Pin<&Self>) -> &String {
        unsafe { &*(self.b) }
    }
}

pub fn main() {
    let test1 = Test::new("test1");
    let test2 = Test::new("test2");

    println!("a: {}, b: {}",test1.as_ref().a(), test1.as_ref().b());
    println!("a: {}, b: {}",test2.as_ref().a(), test2.as_ref().b());
}
```

<!--
Some functions require the futures they work with to be `Unpin`. To use a
`Future` or `Stream` that isn't `Unpin` with a function that requires
`Unpin` types, you'll first have to pin the value using either
`Box::pin` (to create a `Pin<Box<T>>`) or the `pin_utils::pin_mut!` macro
(to create a `Pin<&mut T>`). `Pin<Box<Fut>>` and `Pin<&mut Fut>` can both be
used as futures, and both implement `Unpin`.
-->

Certaines fonctions n√©cessitent que les futures avec lesquelles elles
fonctionnent soient des `Unpin`. Pour utiliser une `Future` ou un `Stream` qui
n'est pas `Unpin` avec une fonction qui n√©cessite des types `Unpin`, vous devez
d'abord √©pingler la valeur en utilisant soit `Box::pin` (pour cr√©er un
`Pin<Box<T>>`) ou la macro `pin_utils::pin_mut!` (pour cr√©er une
`Pin<&mut T>`). `Pin<Box<Future>>` et `Pin<&mut Future>` peuvent tous deux √™tre
utilis√©s comme des `Future`s, et les deux impl√©mentent `Unpin`.

<!--
For example:
-->

Par exemple¬†:

<!--
```rust,edition2018,ignore
use pin_utils::pin_mut; // `pin_utils` is a handy crate available on crates.io

// A function which takes a `Future` that implements `Unpin`.
fn execute_unpin_future(x: impl Future<Output = ()> + Unpin) { /* ... */ }

let fut = async { /* ... */ };
execute_unpin_future(fut); // Error: `fut` does not implement `Unpin` trait

// Pinning with `Box`:
let fut = async { /* ... */ };
let fut = Box::pin(fut);
execute_unpin_future(fut); // OK

// Pinning with `pin_mut!`:
let fut = async { /* ... */ };
pin_mut!(fut);
execute_unpin_future(fut); // OK
```
-->

```rust,edition2018,ignore
use pin_utils::pin_mut; // `pin_utils` est une crate bien pratique,
                        // disponible sur crates.io

// Une fonction qui prend en argument une `Future` qui impl√©mente `Unpin`.
fn executer_une_future_unpin(x: impl Future<Output = ()> + Unpin) { /* ... */ }

let future = async { /* ... */ };
executer_une_future_unpin(future); // Erreur : `future` n'impl√©mente pas
                                   // le trait `Unpin`

// Epingler avec `Box`:
let future = async { /* ... */ };
let future = Box::pin(future);
executer_une_future_unpin(future); // OK

// Epingler avec `pin_mut!`:
let future = async { /* ... */ };
pin_mut!(future);
executer_une_future_unpin(future); // OK
```

<!--
## Summary
-->

## En r√©sum√©

<!--
1. If `T: Unpin` (which is the default), then `Pin<'a, T>` is entirely
equivalent to `&'a mut T`. in other words: `Unpin` means it's OK for this type
to be moved even when pinned, so `Pin` will have no effect on such a type.

2. Getting a `&mut T` to a pinned T requires unsafe if `T: !Unpin`.

3. Most standard library types implement `Unpin`. The same goes for most
"normal" types you encounter in Rust. A `Future` generated by async/await is an exception to this rule.

4. You can add a `!Unpin` bound on a type on nightly with a feature flag, or
by adding `std::marker::PhantomPinned` to your type on stable.

5. You can either pin data to the stack or to the heap.

6. Pinning a `!Unpin` object to the stack requires `unsafe`

7. Pinning a `!Unpin` object to the heap does not require `unsafe`. There is a shortcut for doing this using `Box::pin`.

8. For pinned data where `T: !Unpin` you have to maintain the invariant that its memory will not
get invalidated or repurposed _from the moment it gets pinned until when drop_ is called. This is
an important part of the _pin contract_.
-->

1. Si `T: Unpin` (ce qu'il est par d√©faut), alors `Pin<'a, T>` est strictement
√©quivalent √† `&'a mut T`. Autrement dit¬†: `Unpin` signifie que ce type peut
√™tre d√©plac√© sans probl√®me m√™me lorsqu'il est √©pingl√©, donc `Pin` n'aura pas
d'impact sur ce genre de type.

2. Obtenir un `&mut T` √† partir d'un T √©pingl√© n√©cessite du code non s√©curis√©
si `T: !Unpin`.

3. La plupart des biblioth√®ques standard impl√©mentent `Unpin`. C'est la m√™me
chose pour la plupart des types "normaux" que vous utilisez en Rust. Une
`Future` g√©n√©r√©e par `async` et `await` est une exception √† cette g√©n√©ralit√©.

4. Vous pouvez ajouter un lien `!Unpin` sur un type avec la version
exp√©rimentale de Rust avec un drapeau de fonctionnalit√©, ou en ajoutant le
`std::marker::PhantomPinned` sur votre type avec la version stable.

5. Vous pouvez √©pingler des donn√©es soit sur la pile, soit sur le tas.

6. Epingler un objet `!Unpin` sur la pile n√©cessite `unsafe`

7. Epingler un objet `!Unpin` sur le tas ne n√©cessite pas `unsafe`. Il existe
un raccourci pour faire ceci avec `Box::pin`.

8. Pour les donn√©es √©pingl√©es o√π `T: !Unpin`, vous devez maintenir l'invariant
dont sa m√©moire n'est pas invalid√©e ou r√©affect√©e _√† partir du moment o√π elle
est √©pingl√©e jusqu'√† l'appel √† drop_. C'est une partie tr√®s importante du
_contrat d'√©pinglage_.

<!--
["Executing `Future`s and Tasks"]: ../02_execution/01_chapter.md
[the `Future` trait]: ../02_execution/02_future.md
[pin_utils]: https://docs.rs/pin-utils/
-->

["Executing `Future`s and Tasks"]: ../02_execution/01_chapter.md
[the `Future` trait]: https://rust-lang.github.io/async-book/02_execution/02_future.html
[pin_utils]: https://docs.rs/pin-utils/
